plugins {
    id 'java'
    id 'net.serenity-bdd.serenity-gradle-plugin' version '4.0.1'
}

group = 'com.restfulbooker'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

serenity {
    requirementsDir = "src/test/resources/features"
}

dependencies {
    testImplementation "net.serenity-bdd:serenity-core:4.0.1"
    testImplementation "net.serenity-bdd:serenity-cucumber:4.0.1"
    testImplementation "net.serenity-bdd:serenity-rest-assured:4.0.1"
    testImplementation "net.serenity-bdd:serenity-junit:4.0.1"

    testImplementation "io.cucumber:cucumber-java:7.14.0"
    testImplementation "io.cucumber:cucumber-junit:7.14.0"

    testImplementation "io.rest-assured:rest-assured:5.3.2"
    testImplementation "io.rest-assured:json-path:5.3.2"
    testImplementation "io.rest-assured:json-schema-validator:5.3.2"

    testImplementation "junit:junit:4.13.2"

    testImplementation "org.slf4j:slf4j-simple:2.0.9"

    testImplementation "com.google.code.gson:gson:2.10.1"

    compileOnly("org.projectlombok:lombok:1.18.42")
    annotationProcessor("org.projectlombok:lombok:1.18.42")

    testCompileOnly("org.projectlombok:lombok:1.18.42")
    testAnnotationProcessor("org.projectlombok:lombok:1.18.42")
    compileOnly("com.github.invictum:serenity-reportportal-integration:1.5.7")
}

tasks.withType(Test).configureEach {
    if (System.getProperty("testClass")) {
        filter {
            includeTestsMatching System.getProperty("testClass")
        }
    }
}

test {
    testLogging.showStandardStreams = true
    systemProperties System.properties

    jvmArgs(
            "--add-opens", "java.base/java.lang=ALL-UNNAMED",
            "--add-opens", "java.base/java.util=ALL-UNNAMED",
            "--add-opens", "java.base/java.io=ALL-UNNAMED",
            "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED"
    )

    if (project.hasProperty('environment')) {
        systemProperty 'environment', project.property('environment')
    }

    if (project.hasProperty('maxRetries')) {
        systemProperty 'maxRetries', project.property('maxRetries')
    } else {
        systemProperty 'maxRetries', '3'
    }

    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = true
    }

    ignoreFailures = true
}

// Initial test run - no retries
task runInitialTests(type: Test) {
    testLogging.showStandardStreams = true
    systemProperties System.properties

    jvmArgs(
            "--add-opens", "java.base/java.lang=ALL-UNNAMED",
            "--add-opens", "java.base/java.util=ALL-UNNAMED",
            "--add-opens", "java.base/java.io=ALL-UNNAMED",
            "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED"
    )

    if (project.hasProperty('environment')) {
        systemProperty 'environment', project.property('environment')
    }

    systemProperty 'maxRetries', '0'

    ignoreFailures = true

    doLast {
        if (file("target/rerun.txt").exists()) {
            println "‚úÖ First run complete. Failures detected, will retry."
        } else {
            println "‚úÖ All tests passed on first attempt!"
        }
    }
}

// Retry round 1
task retryRound1(type: Test) {
    testLogging.showStandardStreams = true
    systemProperties System.properties

    jvmArgs(
            "--add-opens", "java.base/java.lang=ALL-UNNAMED",
            "--add-opens", "java.base/java.util=ALL-UNNAMED",
            "--add-opens", "java.base/java.io=ALL-UNNAMED",
            "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED"
    )

    onlyIf {
        file("target/rerun.txt").exists()
    }

    doFirst {
        println "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        println "üîÑ Retry Round 1 of 2"
        println "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"

        def rerunFile = file("target/rerun.txt")
        if (rerunFile.exists()) {
            def rawContent = rerunFile.text.trim()
            println "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            println "üîÑ Parsing rerun.txt for retry"
            println "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            println "Raw content: ${rawContent}"
            println ""

            def scenarios = rawContent.split(/[\s\n]+/)

            def normalizedFeatures = scenarios
                    .collect { scenario ->
                        scenario = scenario.trim()
                        if (scenario.isEmpty()) return null

                        println "  üìç Processing: ${scenario}"

                        // Remove URI prefix
                        def normalized = scenario
                                .replaceFirst(/^file:\/\/\//, "")
                                .replaceFirst(/^file:\//, "")
                                .replaceFirst(/^file:/, "")

                        normalized = normalized.replace("\\", "/")

                        println "     After URI removal: ${normalized}"

                        // Find src/test/resources
                        def srcIndex = normalized.indexOf("src/test/resources")

                        if (srcIndex >= 0) {
                            def relativePath = normalized.substring(srcIndex)
                            println "     ‚úÖ Extracted: ${relativePath}"
                            return relativePath
                        } else {
                            println "     ‚ö†Ô∏è  Could not find 'src/test/resources', trying fallback..."

                            normalized = normalized.replaceFirst(/^[A-Za-z]:\//, "")

                            def workspaceParts = project.projectDir.absolutePath.replace("\\", "/").split("/")
                            def projectName = workspaceParts[-1]

                            println "     Project name: ${projectName}"

                            def projectIndex = normalized.indexOf("/${projectName}/")
                            if (projectIndex >= 0) {
                                normalized = normalized.substring(projectIndex + projectName.length() + 2)
                                println "     ‚úÖ Fallback result: ${normalized}"
                                return normalized
                            } else {
                                def srcIdx = normalized.indexOf("src/")
                                if (srcIdx >= 0) {
                                    normalized = normalized.substring(srcIdx)
                                    println "     ‚úÖ Last resort: ${normalized}"
                                    return normalized
                                }
                            }

                            println "     ‚ùå Could not normalize: ${scenario}"
                            return null
                        }
                    }
                    .findAll { it != null }
                    .join(" ")

            println ""
            println "üéØ Final cucumber.features value:"
            println "   ${normalizedFeatures}"
            println "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            println ""

            if (normalizedFeatures.isEmpty()) {
                throw new GradleException("‚ùå Failed to parse rerun.txt - no valid scenarios found")
            }

            systemProperty 'cucumber.features', normalizedFeatures
            systemProperty 'maxRetries', project.hasProperty('maxRetries') ? project.property('maxRetries') : '3'
        }
    }

    ignoreFailures = true
}

// Retry round 2
task retryRound2(type: Test) {
    testLogging.showStandardStreams = true
    systemProperties System.properties

    jvmArgs(
            "--add-opens", "java.base/java.lang=ALL-UNNAMED",
            "--add-opens", "java.base/java.util=ALL-UNNAMED",
            "--add-opens", "java.base/java.io=ALL-UNNAMED",
            "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED"
    )

    onlyIf {
        file("target/rerun.txt").exists()
    }

    doFirst {
        println "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        println "üîÑ Retry Round 2 of 2"
        println "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"

        def rerunFile = file("target/rerun.txt")
        if (rerunFile.exists()) {
            def rawContent = rerunFile.text.trim()
            println "üîÑ Parsing rerun.txt for retry round 2"
            println "Raw content: ${rawContent}"
            println ""

            def scenarios = rawContent.split(/[\s\n]+/)

            def normalizedFeatures = scenarios
                    .collect { scenario ->
                        scenario = scenario.trim()
                        if (scenario.isEmpty()) return null

                        def normalized = scenario
                                .replaceFirst(/^file:\/\/\//, "")
                                .replaceFirst(/^file:\//, "")
                                .replaceFirst(/^file:/, "")

                        normalized = normalized.replace("\\", "/")

                        def srcIndex = normalized.indexOf("src/test/resources")

                        if (srcIndex >= 0) {
                            return normalized.substring(srcIndex)
                        } else {
                            normalized = normalized.replaceFirst(/^[A-Za-z]:\//, "")

                            def workspaceParts = project.projectDir.absolutePath.replace("\\", "/").split("/")
                            def projectName = workspaceParts[-1]

                            def projectIndex = normalized.indexOf("/${projectName}/")
                            if (projectIndex >= 0) {
                                return normalized.substring(projectIndex + projectName.length() + 2)
                            } else {
                                def srcIdx = normalized.indexOf("src/")
                                if (srcIdx >= 0) {
                                    return normalized.substring(srcIdx)
                                }
                            }
                            return null
                        }
                    }
                    .findAll { it != null }
                    .join(" ")

            println "üéØ Final cucumber.features: ${normalizedFeatures}"
            println ""

            if (normalizedFeatures.isEmpty()) {
                throw new GradleException("‚ùå Failed to parse rerun.txt - no valid scenarios found")
            }

            systemProperty 'cucumber.features', normalizedFeatures
            systemProperty 'maxRetries', project.hasProperty('maxRetries') ? project.property('maxRetries') : '3'
        }
    }

    ignoreFailures = true
}

task checkAfterRetry1 {
    dependsOn retryRound1

    doLast {
        if (!file("target/rerun.txt").exists()) {
            println "\n‚úÖ All tests passed after retry round 1!"
        } else {
            println "\n‚ö†Ô∏è Some tests still failing, will proceed to retry round 2"
        }
    }
}

task checkAfterRetry2 {
    dependsOn retryRound2

    doLast {
        def rerunFile = file("target/rerun.txt")
        if (!rerunFile.exists()) {
            println "\n‚úÖ All tests passed after retry round 2!"
        } else {
            println "\n‚ö†Ô∏è Some tests still failing after 2 retry rounds"
            println "Failed scenarios:"
            println rerunFile.text
        }
    }
}

task testWithRetry {
    dependsOn runInitialTests

    // Configure the dependency chain
    if (project.hasProperty('maxRetryRounds')) {
        def rounds = Integer.parseInt(project.property('maxRetryRounds'))
        if (rounds >= 1) {
            dependsOn retryRound1, checkAfterRetry1
        }
        if (rounds >= 2) {
            dependsOn retryRound2, checkAfterRetry2
            retryRound2.mustRunAfter checkAfterRetry1
            checkAfterRetry2.mustRunAfter retryRound2
        }
    } else {
        // Default: 2 rounds
        dependsOn retryRound1, checkAfterRetry1, retryRound2, checkAfterRetry2
        retryRound2.mustRunAfter checkAfterRetry1
        checkAfterRetry2.mustRunAfter retryRound2
    }

    retryRound1.mustRunAfter runInitialTests
    checkAfterRetry1.mustRunAfter retryRound1

    finalizedBy aggregate
}

tasks.named('aggregate') {
    mustRunAfter test, runInitialTests, retryRound1, retryRound2
}

gradle.startParameter.continueOnFailure = true

serenity {
    reports = ["single-page-html", "json"]
    requirementsBaseDir = "src/test/resources"
}

task verifyAIReport {
    doLast {
        def aiReportFile = file("target/ai-failures.json")
        def rerunSummaryFile = file("target/rerun-summary.json")

        if (aiReportFile.exists()) {
            println "‚úÖ AI Failure Report generated successfully"
            println "   Location: ${aiReportFile.absolutePath}"
            println "   Size: ${aiReportFile.length()} bytes"

            def reportText = aiReportFile.text
            if (reportText.contains('"retryMetadata"')) {
                println "\nüìä Retry Statistics:"
                if (reportText.contains('"scenariosPassedAfterRetry"')) {
                    def passedAfterRetry = (reportText =~ /"scenariosPassedAfterRetry":\s*(\d+)/)[0][1]
                    println "   Scenarios passed after retry: ${passedAfterRetry}"
                }
                if (reportText.contains('"scenariosFailedAllRetries"')) {
                    def failedAllRetries = (reportText =~ /"scenariosFailedAllRetries":\s*(\d+)/)[0][1]
                    println "   Scenarios failed all retries: ${failedAllRetries}"
                }
            }
        } else {
            println "‚ö†Ô∏è AI Failure Report not found at expected location"
            println "   Expected: ${aiReportFile.absolutePath}"
        }

        if (rerunSummaryFile.exists()) {
            println "\n‚úÖ Retry Summary generated successfully"
            println "   Location: ${rerunSummaryFile.absolutePath}"
        }
    }
}

verifyAIReport.mustRunAfter aggregate

task executeTestsWithRetry {
    dependsOn testWithRetry, aggregate, verifyAIReport
    group = 'verification'
    description = 'Run all tests with retry mechanism and generate all reports including AI failure analysis'
}

task executeTests {
    dependsOn test, aggregate, verifyAIReport
    group = 'verification'
    description = 'Run all tests and generate all reports including AI failure analysis (no retry)'
}